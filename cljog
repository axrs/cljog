#!/usr/bin/env bash
set -e
log() {
	echo -e "cljog: $@"
}

error_exit() {
	echo -e "cljog: $@" 1>&2
	exit 1
}

define(){ IFS='\n' read -r -d '' ${1} || true; }

[[ "$BASH_VERSION" < "4" ]] && error_exit "Bash version 4+ is required"

hash clojure 2>/dev/null || error_exit 'Clojure tools not found. Refer https://clojure.org/guides/deps_and_cli'

CLJ_OPTS='-J-Xms256m -J-Xmx256m -J-client -J-XX:MaxMetaspaceSize=100m -J-XX:+TieredCompilation -J-XX:TieredStopAtLevel=1 -J-XX:+UseConcMarkSweepGC -J-XX:+CMSClassUnloadingEnabled -J-Xverify:none -J-Dclojure.spec.skip-macros=true'
VERSION=1.0.0
USER_DEPS='{:deps {}}}'

abs_path() {
	local file
	file="$1"
	cd $(dirname "$file")
	file=$(basename "$file")
	while [[ -L "$file" ]];do
		file="$(readlink "$file")"
		cd "$(dirname "$file")"
		file="$(basename "$file")"
	done
	local dir
	dir="$(pwd -P)"
	echo "$dir/$file"
}

read_deps_edn() {
	local script_dir="$(dirname "$(abs_path "$1")")"
	local file
	file="$2"
	local deps_file="$script_dir/$file"
	if [[ ! -f "$deps_file" ]];then
		error_exit "Unable to resolve '$file' at '$script_dir' while loading dependencies"
	fi
	USER_DEPS=$(<"$deps_file")
}

insert_pomegranate() {
	local deps
	deps="$1"
	local d='clj-commons\/pomegranate {:mvn\/version "1.2.0" :exclusions \[commons-logging\]}'
	local deps_started=0
	local replaced=0
	local lines=""
	while read -r line;do
		if [[ "$replaced" -eq 0 ]]; then
		    # Deps key and open brace on single line
			if echo "$line" | grep -q ":deps\s*{";then
				line=$(echo "$line" | sed -E "s/:deps[[:space:]]*{/:deps {${d} /g")
				replaced=1
		    # Deps key on own line
			elif echo "$line" | grep -q ":deps";then
				deps_started=1
		    # Deps key matched and first open brace
			elif [[ "$deps_started" -eq 1 ]] && [[ "$line" = {* ]];then
				line=$(echo "$line" | sed -E "s/^{/{${d} /g")
			fi
		fi
		lines="${lines}\n${line}"
	done <<< "$deps"
	echo -e ${lines}
}

run_script(){ # path-to-script.clj & args
	local args='['
	for arg in "${@:2}";do
		args="$args \"$arg\""
	done
	args="$args ]"
	local script_dir="$(dirname "$(abs_path "$1")")"

	define clj_script <<EOF
;Fix for modifyable URLClassLoaders for supporting Java9 and up (required for pomegranate 1.0.0+). Refer:
; - https://github.com/cemerick/pomegranate#urlclassloader-modifiability
; - https://github.com/lambdaisland/kaocha/blob/master/src/kaocha/classpath.clj
(do
  (require '[dynapath.util]
           '[clojure.edn]
           '[clojure.java.io])
  (import '(java.io File))

  (defn- ensure-compiler-loader []
    (when-not (bound? Compiler/LOADER)
      (.bindRoot Compiler/LOADER (clojure.lang.DynamicClassLoader. (clojure.lang.RT/baseLoader)))))

  (defn- classloader-hierarchy []
    (ensure-compiler-loader)
    (let [loader (deref Compiler/LOADER)]
      (.setContextClassLoader (.. Thread currentThread) loader)
      (->> loader
           (iterate (fn [x] (.getParent ^ClassLoader x)))
           (take-while boolean))))

  (require '[cemerick.pomegranate])

  (defn deps [m]
    (cond
      (string? m) (deps (clojure.java.io/as-file m))
      (instance? java.io.File m) (if-not (.exists ^java.io.File m)
                                   (throw (Exception. "Deps file not found"))
                                   (->> m
                                        str
                                        slurp
                                        clojure.edn/read-string
                                        :deps
                                        (mapv (fn [[dep v]]
                                                [dep (:mvn/version v) :exclusions (:exclusions v)]))
                                        deps))
      (vector? m) (cemerick.pomegranate/add-dependencies
                    :classloader (last (filter dynapath.util/addable-classpath? (classloader-hierarchy)))
                    :coordinates m
                    :repositories (merge cemerick.pomegranate.aether/maven-central {"clojars" "https://clojars.org/repo"}))
      :else (throw (Exception. "Unknown deps format"))))

  (def ^:dynamic *cljog-version* "$VERSION")
  (def ^:dynamic *cwd* (System/getProperty "user.dir"))
  (def ^:dynamic *script* "$1")
  (def ^:dynamic *script-dir* "$script_dir")

  (binding [*command-line-args* $args]
    (load-file *script*))
  nil)
EOF
	#language=clj
	local DEPS=$(insert_pomegranate "$USER_DEPS")
	exec clojure $CLJ_OPTS -Sdeps "$DEPS" -e "$clj_script"
}

update_clis(){ #namespaces
	local namespaces=$1
	local tmpdir=$(dirname $(mktemp -u))
	define clj_script <<EOF
(deps '[[clj-http "3.10.0"]
        [cheshire "5.9.0"]])

(require
  '[clj-http.client :as client]
  '[clojure.string :as str])

(def groups (some-> *command-line-args* seq first (str/split #",")))
(def connection-pool-defaults {:timeout 5 :threads 4 :insecure? false :default-per-route 10})

(defn- ->dep [group-key artifact-key version-key m]
  (when-let [group (group-key m)]
    (let [cli (str group \/ (artifact-key m))]
      [(symbol cli) (version-key m)])))

(defn- fetch-from-clojars [groups]
  (let [clis (atom [])]
    (client/with-connection-pool connection-pool-defaults
      (doseq [group groups]
        (->> (client/get (str "https://clojars.org/api/groups/" group) {:accept           :application/edn
                                                                        :throw-exceptions false
                                                                        :as               :clojure})
          :body
          (swap! clis concat))))
    (keep (partial ->dep :group_name :jar_name :latest_version) @clis)))

(defn- fetch-from-mvn [groups]
  (let [clis (atom [])]
    (client/with-connection-pool connection-pool-defaults
      (doseq [group groups]
        (->> (client/get "https://search.maven.org/solrsearch/select"
               {:throw-exceptions false
                :accept           :json
                :query-params     {:q    (str "g:\"" group "\"")
                                   :wt   "json"
                                   :rows 1000}
                :as               :json})
          :body
          :response
          :docs
          (filter (comp (partial = "jar") :p))
          (swap! clis concat))))
    (keep (partial ->dep :g :a :latestVersion) @clis)))

(defn- print-clis [deps-v]
  (println "Downloading CLIs:")
  (mapv (fn [[cli version]]
          (println \tab cli version))
    deps-v)
  deps-v)

(when (seq groups)
  (some->> (concat
             (fetch-from-clojars groups)
             (fetch-from-mvn groups))
    seq
    print-clis
    deps))
EOF
	echo "$clj_script" > "$tmpdir/cljog_update.clj"
	run_script "$tmpdir/cljog_update.clj" "$namespaces"
}

if test -f "$1";then
	run_script "${@:1}"
else
	config_file=$HOME/.cljog

	sed_escape() {
		sed -e 's/[]\/$*.^[]/\\&/g'
	}

	cfg_delete() { # key
		test -f "$config_file" && sed -i.bak "/^$(echo $1 | sed_escape)/d" "$config_file" && rm "${config_file}.bak"
	}

	cfg_write() { # key, value
		cfg_delete "$1"
		echo "$1=$2" >> "$config_file"
	}

	cfg_read() { # key
		test -f "$config_file" && grep "^$(echo "$1" | sed_escape)=" "$config_file" | sed "s/^$(echo "$1" | sed_escape)=//" | tail -1
	}

	cfg_haskey() { # key
		test -f "$config_file" && grep "^$(echo "$1" | sed_escape)=" "$config_file" > /dev/null
	}

	initialise_config() {
		if [[ ! -f "$config_file" ]];then
			log "Initialising config file: $config_file"
			touch "$config_file"
			cfg_write discovery_namespaces ""
			if hash mvn 2>/dev/null;then
				repo_path=$(mvn help:evaluate -Dexpression=settings.localRepository -q -DforceStdout)
				cfg_write repository "$(dirname $repo_path)"
			else
				cfg_write repository ""
			fi
		fi
	}

	mvn_home=""
	local_repo=""
	namespaces=""

	load_config_vars() {
		initialise_config
		mvn_home=$(cfg_read repository)
		local_repo="$mvn_home/repository"
		namespaces=$(cfg_read discovery_namespaces)
	}

	assert_repo_root(){
		if [[ -z "$mvn_home" ]];then
			error_exit "'repository' config value is not set.\nRun 'cljog --config-set repository /path/to/.m2' to configure."
		elif [[ ! -d "$local_repo" ]];then
			error_exit "'repository' directory ($local_repo) not found."
		fi
	}

	assert_namespace_config(){
		if [[ -z "$namespaces" ]];then
			error_exit "'discovery_namespaces' config value is not set.\nRun 'cljog --config-set discovery_namespaces your.first.ns,your.second.ns' to configure."
		fi
	}

	declare -A clis

	discover_clis() {
		load_config_vars
		assert_repo_root
		assert_namespace_config
		namespaces=(${namespaces//,/ })
		for i in ${!namespaces[@]};do
			namespaces[$i]="${local_repo}/${namespaces[$i]//./\/}"
		done
		local artifacts=$(find ${namespaces[@]} -name *.jar 2>/dev/null | tac)
		local repo_dir_str_length=$((${#local_repo} + 1))
		for artifact in ${artifacts};do
			local artifact="${artifact:$repo_dir_str_length}"
			local groupId=$(echo "$artifact" | rev | cut -d/ -f4- | rev | tr / .)
			local artifactId=$(echo "$artifact" | awk -F/ '{print $(NF-2)}')
			local version=$(echo "$artifact" | awk -F/ '{print $(NF-1)}')
			local cli="$groupId/$artifactId"
			local knownVersion=${clis["$cli"]}
			if [[ ${version} > ${knownVersion} ]];then
				clis["$cli"]="$version"
			fi
		done
	}

	list_clis() {
		load_config_vars
		hash column 2>/dev/null || error_exit "'column' command not found."
		echo "Local Commands in: $local_repo"
		local tty_width=$(stty size | awk '{print $2}')
		for dep in "${!clis[@]}";do
			local artifact=$(echo "$dep" | awk -F/ '{print $NF}')
			local version="${clis[$dep]}"
			local pom="$local_repo/$(echo "$dep" | tr . /)/$version/*$version.pom"
			pom=$(realpath ${pom})
			local groupId=$(echo ${dep} | cut -d/ -f1)
			if test -f "$pom";then
				echo -e "    $artifact\t$groupId\t$version\t$(awk -F '[<>]' '/description/{print $3}' "$pom")"
			fi
		done | column -ts $'\t' | sort | cut -b -${tty_width}
	}

	run_cli(){
		local dep
		local version
		for cli in "${!clis[@]}";do
			if [[ "$cli" == */${1} ]];then
				dep=$cli
				version="${clis[$cli]}"
				break
			fi
		done
		if [[ -n "$version" ]];then
				local DEPS="{:paths [] :deps {$dep {:mvn/version \"${version}\"}}}"
				local ns=$(echo $cli | tr / .)
				exec clojure $CLJ_OPTS -Sdeps "$DEPS" -m ${ns}.core "${@:2}"
		else
			error_exit "Unable to find cli '$1'. Run 'cljog --list' to see a list of all available commands"
		fi
	}

	config () {
		if [[ -n "$1" ]] && [[ -n "$2" ]];then
			cfg_write "$1" "$2"
		elif [[ -n "$1" ]];then
			cfg_delete "$1"
		fi
	}

	run_script_with_deps() {
		local deps_file
		deps_file="$1"
		local script_file
		script_file="$2"
		shift
		local root_dir
		root_dir=$(abs_path "script_file")
		read_deps_edn "$script_file" "$deps_file"
		run_script "$@"
	}

	case "$1" in
		--deps)
			shift
			run_script_with_deps "deps.edn" "$@";;
		*"--deps="*)
			deps_file=$(cut -d "=" -f2- <<< "$1")
			shift
			run_script_with_deps "$deps_file" "$@";;
		--config)
			log "${config_file}\n"
			cat ${config_file};;
		--config-get)
			cfg_read "$2";;
		--config-set)
			config "${@:2}";;
		--update|-u)
			load_config_vars
			assert_namespace_config
			log "Updating CLIs for $namespaces"
			update_clis "$namespaces";;
		--list|-l)
			discover_clis
			list_clis;;
		--version)
			echo "$VERSION";;
		""|--help)
			define usage <<EOF
command discovery
	'cljog --list'                   Prints a list of installed commands
	'cljog --update'                 Search for, installs, and updates commands matching
	                                 the configured 'discovery_namespaces' config
	'cljog cmd [arg1] [arg2] [arg3]' Runs an installed command with provided args

config
	'cljog --config'                 Print the entire config
	'cljog --config-set key [value]' Set (or clear) a config value
	'cljog --config-get key'         Get a config value

miscellaneous
	'cljog --version'                Prints the current version
EOF
			echo -e "$usage";;
		*)
			discover_clis
			run_cli "${@:1}";;
	esac
fi
